Index: src/main/java/org/calculus/bracketsAndChainBills/MathExpressionEvaluator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.calculus.bracketsAndChainBills;\r\nimport java.util.Stack;\r\n\r\nimport org.calculus.calculate.ExtendedOperations;\r\n\r\npublic class MathExpressionEvaluator {\r\n    private static String currentExpression = \"0\";\r\n    private static String currentResult = \"\";\r\n    private static final ExtendedOperations extendedOperations = new ExtendedOperations();\r\n\r\n    public static double calculate(String expression) {\r\n        //Macht aus der String Expression einen Char Array und Initialisiert 2 Stacks\r\n        //Ein Stack ist für die Zahlen und der andere für die Operationen zuständig.\r\n        currentExpression = expression;\r\n        char[] tokens = expression.toCharArray();\r\n        Stack<Double> values = new Stack<>();\r\n        Stack<Character> ops = new Stack<>();\r\n\r\n        //durchläuft den Character Array\r\n        for (int i = 0; i < tokens.length; i++) {\r\n            //Wenn eine Zahl zwischen 1 und 9 gefunden wird, wird ein Stringbuilder initialisiert\r\n            if (tokens[i] >= '0' && tokens[i] <= '9'|| tokens[i] == '.') {\r\n                StringBuilder sbuf = new StringBuilder();\r\n                //Solange i eine Zahl abbildet wird sie diesem neu gebautem String hinzugefügt\r\n                while (i < tokens.length && (tokens[i] >= '0' && tokens[i] <= '9' || tokens[i] == '.')) {\r\n                    sbuf.append(tokens[i++]);\r\n                }\r\n                \r\n                //der Zahlen String wird in den Value Stack gelegt und i um ein veringert um die for schleife weiter zu durchlaufen\r\n                values.push(Double.parseDouble(sbuf.toString()));\r\n                i--;\r\n                //Wenn i eine öffnende klammer darstellt wird diese auf den ops stack gelegt\r\n            } else if (tokens[i] == '(') {\r\n                ops.push(tokens[i]);\r\n                if (i > 0 && tokens[i - 1] >= '0' && tokens[i - 1] <= '9') {\r\n                    ops.push('*');\r\n                }\r\n                //wird eine schliessende klammer gefunden, werden alle bisherigen operationen ausgeführt bis\r\n                //eine öffnende klammer (indemfall der schluss der klammer) gefunden wird\r\n            } else if (tokens[i] == ')') {\r\n                while (ops.peek() != '(') {\r\n                    values.push(applyOp(ops.pop(), values.pop(), values.pop()));\r\n\r\n                }\r\n                ops.pop();\r\n                //wenn i + - * oder / darstellt, wird geschaut ob der Operator priorität hat oder nicht\r\n            } else if (tokens[i] == '+' || tokens[i] == '-' || tokens[i] == '*' || tokens[i] == '/') {\r\n                while (!ops.empty() && hasPrecedence(tokens[i], ops.peek())) {\r\n                    values.push(applyOp(ops.pop(), values.pop(), values.pop()));\r\n                }\r\n                ops.push(tokens[i]);\r\n            }\r\n        }\r\n\r\n        while (!ops.empty()) {\r\n            values.push(applyOp(ops.pop(), values.pop(), values.pop()));\r\n        }\r\n        double result = values.pop();\r\n        currentResult = String.valueOf(result);\r\n        return result;\r\n    }\r\n    //prüft den vorrang einer Opertaion\r\n    public static boolean hasPrecedence(char op1, char op2) {\r\n        //ist op 2 entweder eine öffnende oder schliessende klammer, hat diese keinen vorang und es wird false zurück gegeben\r\n        if (op2 == '(' || op2 == ')') {\r\n            return false;\r\n        }\r\n        //ist die erste Operation kein * oder / oder die 2 Operation kein + oder - wird true zurück gegeben\r\n        return (op1 != '*' && op1 != '/') || (op2 != '+' && op2 != '-');\r\n    }\r\n    //führt die Operationen auf basis eines Switchcases durch.\r\n    public static double applyOp(char op, double b, double a) {\r\n        return switch (op) {\r\n            case '+' -> a + b;\r\n            case '-' -> a - b;\r\n            case '*' -> a * b;\r\n            case '/' -> {\r\n                if (b == 0 || a == 0) {\r\n                    yield 0;\r\n                }\r\n                yield a / b;\r\n            }\r\n            case '%' -> extendedOperations.modulo(((Double) a), ((Double) b));\r\n            default -> 0;\r\n        };\r\n    }\r\n    public static String getExpressionAndResult(){\r\n\r\n        return currentExpression + \"=\" + currentResult;\r\n    }\r\n    public static String getCurrentResult(){\r\n        return currentResult;\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/calculus/bracketsAndChainBills/MathExpressionEvaluator.java b/src/main/java/org/calculus/bracketsAndChainBills/MathExpressionEvaluator.java
--- a/src/main/java/org/calculus/bracketsAndChainBills/MathExpressionEvaluator.java	
+++ b/src/main/java/org/calculus/bracketsAndChainBills/MathExpressionEvaluator.java	
@@ -80,7 +80,7 @@
                 }
                 yield a / b;
             }
-            case '%' -> extendedOperations.modulo(((Double) a), ((Double) b));
+            case '%' -> extendedOperations.modulo(a, b);
             default -> 0;
         };
     }
